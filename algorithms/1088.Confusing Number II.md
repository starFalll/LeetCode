### [1088. Confusing Number II](https://leetcode.com/problems/confusing-number-ii/)

A **confusing number** is a number that when rotated `180` degrees becomes a different number with **each digit valid**.

We can rotate digits of a number by `180` degrees to form new digits.

- When `0`, `1`, `6`, `8`, and `9` are rotated `180` degrees, they become `0`, `1`, `9`, `8`, and `6` respectively.
- When `2`, `3`, `4`, `5`, and `7` are rotated `180` degrees, they become **invalid**.

Note that after rotating a number, we can ignore leading zeros.

- For example, after rotating `8000`, we have `0008` which is considered as just `8`.

Given an integer `n`, return *the number of **confusing numbers** in the inclusive range* `[1, n]`.

 

**Example 1:**

```
Input: n = 20
Output: 6
Explanation: The confusing numbers are [6,9,10,16,18,19].
6 converts to 9.
9 converts to 6.
10 converts to 01 which is just 1.
16 converts to 91.
18 converts to 81.
19 converts to 61.
```

**Example 2:**

```
Input: n = 100
Output: 19
Explanation: The confusing numbers are [6,9,10,16,18,19,60,61,66,68,80,81,86,89,90,91,98,99,100].
```

 

**Constraints:**

- `1 <= n <= 109`

#### 解析

DFS backtracing

#### 代码

```c++
class Solution {
private:
    unordered_map<int, int> m = {{1,1}, {6, 9}, {9, 6}, {8, 8}, {0, 0}};
    vector<int> valid = {0,1,6,8,9};
    void DFS(long long val, long long rotation, long long digit, int n, int& res) {
        if (val && val != rotation && val <= n) res++;
        for (int i = 0; i < valid.size(); i++) {
            if (val * 10 + valid[i] > n) break;
            DFS(val*10+valid[i], m[valid[i]]*digit+rotation, digit*10, n, res);
        }
    } 
public:
    int confusingNumberII(int n) {
        int res = 0;
        DFS(1, 1, 10, n, res);
        DFS(6, 9, 10, n, res);
        DFS(9, 6, 10, n, res);
        DFS(8, 8, 10, n, res);
        return res;
    }
};
```
