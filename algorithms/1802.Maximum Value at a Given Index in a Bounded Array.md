### [1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/)

You are given three positive integers: `n`, `index`, and `maxSum`. You want to construct an array `nums` (**0-indexed**) that satisfies the following conditions:

- `nums.length == n`
- `nums[i]` is a **positive** integer where `0 <= i < n`.
- `abs(nums[i] - nums[i+1]) <= 1` where `0 <= i < n-1`.
- The sum of all the elements of `nums` does not exceed `maxSum`.
- `nums[index]` is **maximized**.

Return `nums[index]` *of the constructed array*.

Note that `abs(x)` equals `x` if `x >= 0`, and `-x` otherwise.

 

**Example 1:**

```
Input: n = 4, index = 2,  maxSum = 6
Output: 2
Explanation: nums = [1,2,2,1] is one array that satisfies all the conditions.
There are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].
```

**Example 2:**

```
Input: n = 6, index = 1,  maxSum = 10
Output: 3
```

 

**Constraints:**

- `1 <= n <= maxSum <= 109`
- `0 <= index < n`

#### Solution

time complexity: logn

space complexity: constant

binary search + compute

Compute: index is mid, decrease in sequence on both sides, special situation: min val is 1.

#### Code

```c++
class Solution {
public:
    int maxValue(int n, int index, int maxSum) {
        int left = 1, right = maxSum;
        long long l = index, r = n - index - 1;
        while (left <= right) {
            long long mid = (left+right) / 2;
            long long total = 0;
            if (mid > l) {
                total += (2*mid-l-1)*l/2;
            }
            else {
                total += mid*(mid-1)/2 + l-mid+1;
            }

            if (mid > r) {
                total += (2*mid-r-1)*r/2;
            }
            else {
                total += mid*(mid-1)/2 + r-mid+1;
            }
            total += mid;
            if (total > maxSum) {
                right = mid-1;
            }
            else if (total < maxSum) {
                left = mid+1;
            }
            else return mid;
        }
        return right;
    }
};
```



